/*
 * SPDX-FileCopyrightText: Copyright 2025 Arm Limited and/or its affiliates
 * SPDX-License-Identifier: Apache-2.0
 * 
 * SPIR-V and Shader Unit Tests for ARM ML SDK
 * Tests shader module loading, SPIR-V validation, specialization constants,
 * and compute shader execution.
 */

#include <gtest/gtest.h>
#include <vulkan/vulkan.hpp>
#include <vulkan/vulkan_raii.hpp>
#include <vector>
#include <memory>
#include <fstream>
#include <cstring>
#include <array>

namespace mlsdk::tests {

class SPIRVShaderTest : public ::testing::Test {
protected:
    vk::raii::Context context;
    vk::raii::Instance instance{nullptr};
    vk::raii::PhysicalDevice physicalDevice{nullptr};
    vk::raii::Device device{nullptr};
    uint32_t queueFamilyIndex = 0;
    vk::raii::Queue computeQueue{nullptr};
    vk::raii::CommandPool commandPool{nullptr};
    
    void SetUp() override {
        // Create Vulkan instance
        vk::ApplicationInfo appInfo{
            "SPIRVShaderTests",
            VK_MAKE_VERSION(1, 0, 0),
            "ARM ML SDK Tests",
            VK_MAKE_VERSION(1, 0, 0),
            VK_API_VERSION_1_2
        };
        
        std::vector<const char*> extensions;
        std::vector<const char*> layers;
        
#ifdef DEBUG
        extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
        layers.push_back("VK_LAYER_KHRONOS_validation");
#endif
        
        vk::InstanceCreateInfo instanceCreateInfo{
            {},
            &appInfo,
            layers,
            extensions
        };
        
        instance = vk::raii::Instance(context, instanceCreateInfo);
        
        // Select physical device
        auto physicalDevices = vk::raii::PhysicalDevices(instance);
        ASSERT_FALSE(physicalDevices.empty());
        physicalDevice = std::move(physicalDevices[0]);
        
        // Find compute queue family
        auto queueFamilyProperties = physicalDevice.getQueueFamilyProperties();
        for (uint32_t i = 0; i < queueFamilyProperties.size(); ++i) {
            if (queueFamilyProperties[i].queueFlags & vk::QueueFlagBits::eCompute) {
                queueFamilyIndex = i;
                break;
            }
        }
        
        // Create logical device
        float queuePriority = 1.0f;
        vk::DeviceQueueCreateInfo queueCreateInfo{
            {},
            queueFamilyIndex,
            1,
            &queuePriority
        };
        
        vk::PhysicalDeviceFeatures deviceFeatures{};
        vk::DeviceCreateInfo deviceCreateInfo{
            {},
            queueCreateInfo,
            {},
            {},
            &deviceFeatures
        };
        
        device = vk::raii::Device(physicalDevice, deviceCreateInfo);
        computeQueue = vk::raii::Queue(device, queueFamilyIndex, 0);
        
        // Create command pool
        vk::CommandPoolCreateInfo poolInfo{
            vk::CommandPoolCreateFlagBits::eResetCommandBuffer,
            queueFamilyIndex
        };
        commandPool = vk::raii::CommandPool(device, poolInfo);
    }
    
    void TearDown() override {
        if (*device) {
            device.waitIdle();
        }
    }
    
    // Helper function to create a simple add shader SPIR-V
    std::vector<uint32_t> createAddShaderSPIRV() {
        // Minimal SPIR-V for: void main() { outBuffer[gl_GlobalInvocationID.x] = inBuffer1[gl_GlobalInvocationID.x] + inBuffer2[gl_GlobalInvocationID.x]; }
        // This is a simplified representation - actual SPIR-V would be generated by glslang
        std::vector<uint32_t> spirv = {
            0x07230203, // Magic number
            0x00010300, // Version 1.3
            0x00000000, // Generator
            0x00000001, // Bound
            0x00000000, // Schema
            // Note: This is placeholder SPIR-V - real implementation would use glslang or load from file
        };
        return spirv;
    }
    
    // Helper to load SPIR-V from file
    std::vector<uint32_t> loadSPIRVFromFile(const std::string& filename) {
        std::ifstream file(filename, std::ios::binary | std::ios::ate);
        if (!file.is_open()) {
            return {};
        }
        
        size_t fileSize = file.tellg();
        std::vector<uint32_t> spirv(fileSize / sizeof(uint32_t));
        file.seekg(0);
        file.read(reinterpret_cast<char*>(spirv.data()), fileSize);
        file.close();
        
        return spirv;
    }
};

// Test 1: Shader Module Creation
TEST_F(SPIRVShaderTest, ShaderModuleCreation) {
    auto spirvCode = createAddShaderSPIRV();
    
    vk::ShaderModuleCreateInfo shaderInfo{
        {},
        spirvCode.size() * sizeof(uint32_t),
        spirvCode.data()
    };
    
    // This will fail with placeholder SPIR-V, but tests the API
    try {
        vk::raii::ShaderModule shaderModule(device, shaderInfo);
        EXPECT_TRUE(*shaderModule) << "Shader module should be created";
    } catch (const vk::SystemError& e) {
        // Expected with invalid SPIR-V
        GTEST_SKIP() << "Skipping with placeholder SPIR-V";
    }
}

// Test 2: Specialization Constants
TEST_F(SPIRVShaderTest, SpecializationConstants) {
    // Define specialization constants
    struct SpecConstants {
        uint32_t workgroupSizeX = 16;
        uint32_t workgroupSizeY = 16;
        float scale = 2.0f;
    } specData;
    
    std::array<vk::SpecializationMapEntry, 3> specMapEntries = {{
        {0, offsetof(SpecConstants, workgroupSizeX), sizeof(uint32_t)},
        {1, offsetof(SpecConstants, workgroupSizeY), sizeof(uint32_t)},
        {2, offsetof(SpecConstants, scale), sizeof(float)}
    }};
    
    vk::SpecializationInfo specInfo{
        static_cast<uint32_t>(specMapEntries.size()),
        specMapEntries.data(),
        sizeof(SpecConstants),
        &specData
    };
    
    // Create pipeline with specialization constants
    auto spirvCode = createAddShaderSPIRV();
    vk::ShaderModuleCreateInfo shaderInfo{
        {},
        spirvCode.size() * sizeof(uint32_t),
        spirvCode.data()
    };
    
    try {
        vk::raii::ShaderModule shaderModule(device, shaderInfo);
        
        vk::PipelineShaderStageCreateInfo stageInfo{
            {},
            vk::ShaderStageFlagBits::eCompute,
            *shaderModule,
            "main",
            &specInfo // Specialization constants
        };
        
        EXPECT_EQ(stageInfo.pSpecializationInfo->mapEntryCount, 3);
    } catch (const vk::SystemError& e) {
        GTEST_SKIP() << "Skipping with placeholder SPIR-V";
    }
}

// Test 3: Compute Shader Execution (Vector Addition)
TEST_F(SPIRVShaderTest, ComputeShaderVectorAddition) {
    const uint32_t numElements = 1024;
    const VkDeviceSize bufferSize = numElements * sizeof(float);
    
    // Create buffers
    vk::BufferCreateInfo bufferInfo{
        {},
        bufferSize,
        vk::BufferUsageFlagBits::eStorageBuffer,
        vk::SharingMode::eExclusive
    };
    
    vk::raii::Buffer bufferA(device, bufferInfo);
    vk::raii::Buffer bufferB(device, bufferInfo);
    vk::raii::Buffer bufferC(device, bufferInfo);
    
    // Allocate memory
    auto memRequirements = bufferA.getMemoryRequirements();
    auto memProperties = physicalDevice.getMemoryProperties();
    
    uint32_t memoryTypeIndex = UINT32_MAX;
    for (uint32_t i = 0; i < memProperties.memoryTypeCount; ++i) {
        if ((memRequirements.memoryTypeBits & (1 << i)) &&
            (memProperties.memoryTypes[i].propertyFlags & vk::MemoryPropertyFlagBits::eHostVisible)) {
            memoryTypeIndex = i;
            break;
        }
    }
    ASSERT_NE(memoryTypeIndex, UINT32_MAX);
    
    vk::MemoryAllocateInfo allocInfo{
        memRequirements.size * 3,
        memoryTypeIndex
    };
    
    vk::raii::DeviceMemory memory(device, allocInfo);
    bufferA.bindMemory(*memory, 0);
    bufferB.bindMemory(*memory, memRequirements.size);
    bufferC.bindMemory(*memory, memRequirements.size * 2);
    
    // Initialize input data
    float* mappedMemory = static_cast<float*>(memory.mapMemory(0, memRequirements.size * 3));
    for (uint32_t i = 0; i < numElements; ++i) {
        mappedMemory[i] = static_cast<float>(i);                    // Buffer A
        mappedMemory[numElements + i] = static_cast<float>(i * 2);  // Buffer B
    }
    memory.unmapMemory();
    
    // Create descriptor set layout
    std::array<vk::DescriptorSetLayoutBinding, 3> layoutBindings = {{
        {0, vk::DescriptorType::eStorageBuffer, 1, vk::ShaderStageFlagBits::eCompute},
        {1, vk::DescriptorType::eStorageBuffer, 1, vk::ShaderStageFlagBits::eCompute},
        {2, vk::DescriptorType::eStorageBuffer, 1, vk::ShaderStageFlagBits::eCompute}
    }};
    
    vk::DescriptorSetLayoutCreateInfo layoutInfo{
        {},
        layoutBindings
    };
    
    vk::raii::DescriptorSetLayout descriptorSetLayout(device, layoutInfo);
    
    // Create descriptor pool
    vk::DescriptorPoolSize poolSize{
        vk::DescriptorType::eStorageBuffer,
        3
    };
    
    vk::DescriptorPoolCreateInfo poolInfo{
        {},
        1,
        poolSize
    };
    
    vk::raii::DescriptorPool descriptorPool(device, poolInfo);
    
    // Allocate descriptor set
    vk::DescriptorSetAllocateInfo descAllocInfo{
        *descriptorPool,
        *descriptorSetLayout
    };
    
    auto descriptorSets = vk::raii::DescriptorSets(device, descAllocInfo);
    
    // Update descriptor set
    std::array<vk::DescriptorBufferInfo, 3> bufferInfos = {{
        {*bufferA, 0, VK_WHOLE_SIZE},
        {*bufferB, 0, VK_WHOLE_SIZE},
        {*bufferC, 0, VK_WHOLE_SIZE}
    }};
    
    std::array<vk::WriteDescriptorSet, 3> descriptorWrites = {{
        {*descriptorSets[0], 0, 0, vk::DescriptorType::eStorageBuffer, {}, bufferInfos[0]},
        {*descriptorSets[0], 1, 0, vk::DescriptorType::eStorageBuffer, {}, bufferInfos[1]},
        {*descriptorSets[0], 2, 0, vk::DescriptorType::eStorageBuffer, {}, bufferInfos[2]}
    }};
    
    device.updateDescriptorSets(descriptorWrites, {});
    
    // Note: Actual compute execution would require valid SPIR-V shader
    // This test validates the setup and API usage
    EXPECT_TRUE(*descriptorSets[0]) << "Descriptor set should be valid";
}

// Test 4: Multiple Shader Stages in Pipeline
TEST_F(SPIRVShaderTest, MultipleShadersInPipeline) {
    // Test creating pipeline with multiple shader modules
    auto spirvCode1 = createAddShaderSPIRV();
    auto spirvCode2 = createAddShaderSPIRV(); // Would be different shader in real scenario
    
    vk::ShaderModuleCreateInfo shaderInfo1{
        {},
        spirvCode1.size() * sizeof(uint32_t),
        spirvCode1.data()
    };
    
    vk::ShaderModuleCreateInfo shaderInfo2{
        {},
        spirvCode2.size() * sizeof(uint32_t),
        spirvCode2.data()
    };
    
    try {
        vk::raii::ShaderModule shaderModule1(device, shaderInfo1);
        vk::raii::ShaderModule shaderModule2(device, shaderInfo2);
        
        // Both modules should be created (even if invalid)
        EXPECT_TRUE(*shaderModule1 || *shaderModule2);
    } catch (const vk::SystemError& e) {
        GTEST_SKIP() << "Skipping with placeholder SPIR-V";
    }
}

// Test 5: Push Constants in Compute Shader
TEST_F(SPIRVShaderTest, ComputeShaderPushConstants) {
    struct PushConstants {
        float scale;
        float bias;
        uint32_t count;
        uint32_t offset;
    };
    
    // Create pipeline layout with push constants
    vk::PushConstantRange pushConstantRange{
        vk::ShaderStageFlagBits::eCompute,
        0,
        sizeof(PushConstants)
    };
    
    vk::PipelineLayoutCreateInfo layoutInfo{
        {},
        {},
        pushConstantRange
    };
    
    vk::raii::PipelineLayout pipelineLayout(device, layoutInfo);
    
    // Allocate command buffer
    vk::CommandBufferAllocateInfo allocInfo{
        *commandPool,
        vk::CommandBufferLevel::ePrimary,
        1
    };
    auto commandBuffers = vk::raii::CommandBuffers(device, allocInfo);
    
    // Record push constants
    PushConstants pushData{2.0f, 1.0f, 1024, 0};
    
    commandBuffers[0].begin({vk::CommandBufferUsageFlagBits::eOneTimeSubmit});
    
    // Push constants
    commandBuffers[0].pushConstants(
        *pipelineLayout,
        vk::ShaderStageFlagBits::eCompute,
        0,
        sizeof(PushConstants),
        &pushData
    );
    
    commandBuffers[0].end();
    
    EXPECT_TRUE(*commandBuffers[0]) << "Command buffer should be valid";
}

// Test 6: Shader Resource Limits
TEST_F(SPIRVShaderTest, ShaderResourceLimits) {
    auto properties = physicalDevice.getProperties();
    auto limits = properties.limits;
    
    // Check compute shader limits
    EXPECT_GT(limits.maxComputeSharedMemorySize, 0) << "Shared memory size should be > 0";
    EXPECT_GT(limits.maxComputeWorkGroupCount[0], 0) << "Work group count X should be > 0";
    EXPECT_GT(limits.maxComputeWorkGroupCount[1], 0) << "Work group count Y should be > 0";
    EXPECT_GT(limits.maxComputeWorkGroupCount[2], 0) << "Work group count Z should be > 0";
    EXPECT_GT(limits.maxComputeWorkGroupInvocations, 0) << "Max invocations should be > 0";
    EXPECT_GT(limits.maxComputeWorkGroupSize[0], 0) << "Work group size X should be > 0";
    EXPECT_GT(limits.maxComputeWorkGroupSize[1], 0) << "Work group size Y should be > 0";
    EXPECT_GT(limits.maxComputeWorkGroupSize[2], 0) << "Work group size Z should be > 0";
    
    // Check descriptor limits
    EXPECT_GT(limits.maxBoundDescriptorSets, 0) << "Max descriptor sets should be > 0";
    EXPECT_GT(limits.maxDescriptorSetStorageBuffers, 0) << "Max storage buffers should be > 0";
    EXPECT_GT(limits.maxDescriptorSetStorageImages, 0) << "Max storage images should be > 0";
    
    // Check push constant limits
    EXPECT_GE(limits.maxPushConstantsSize, 128) << "Push constants size should be >= 128";
}

// Test 7: Compute Dispatch
TEST_F(SPIRVShaderTest, ComputeDispatch) {
    // Create pipeline layout
    vk::PipelineLayoutCreateInfo layoutInfo{};
    vk::raii::PipelineLayout pipelineLayout(device, layoutInfo);
    
    // Create shader module (would be real SPIR-V in production)
    auto spirvCode = createAddShaderSPIRV();
    vk::ShaderModuleCreateInfo shaderInfo{
        {},
        spirvCode.size() * sizeof(uint32_t),
        spirvCode.data()
    };
    
    try {
        vk::raii::ShaderModule shaderModule(device, shaderInfo);
        
        // Create compute pipeline
        vk::ComputePipelineCreateInfo pipelineInfo{
            {},
            {
                {},
                vk::ShaderStageFlagBits::eCompute,
                *shaderModule,
                "main"
            },
            *pipelineLayout
        };
        
        auto pipelines = vk::raii::Pipelines(device, nullptr, pipelineInfo);
        
        // Allocate command buffer
        vk::CommandBufferAllocateInfo allocInfo{
            *commandPool,
            vk::CommandBufferLevel::ePrimary,
            1
        };
        auto commandBuffers = vk::raii::CommandBuffers(device, allocInfo);
        
        // Record dispatch
        commandBuffers[0].begin({vk::CommandBufferUsageFlagBits::eOneTimeSubmit});
        commandBuffers[0].bindPipeline(vk::PipelineBindPoint::eCompute, *pipelines[0]);
        
        // Dispatch compute work
        uint32_t groupCountX = 64;
        uint32_t groupCountY = 1;
        uint32_t groupCountZ = 1;
        commandBuffers[0].dispatch(groupCountX, groupCountY, groupCountZ);
        
        commandBuffers[0].end();
        
        EXPECT_TRUE(*commandBuffers[0]) << "Command buffer should be valid";
    } catch (const vk::SystemError& e) {
        GTEST_SKIP() << "Skipping with placeholder SPIR-V";
    }
}

// Test 8: Indirect Dispatch
TEST_F(SPIRVShaderTest, IndirectDispatch) {
    // Create indirect buffer
    struct DispatchIndirectCommand {
        uint32_t x;
        uint32_t y;
        uint32_t z;
    };
    
    VkDeviceSize bufferSize = sizeof(DispatchIndirectCommand);
    
    vk::BufferCreateInfo bufferInfo{
        {},
        bufferSize,
        vk::BufferUsageFlagBits::eIndirectBuffer,
        vk::SharingMode::eExclusive
    };
    
    vk::raii::Buffer indirectBuffer(device, bufferInfo);
    
    // Allocate memory
    auto memRequirements = indirectBuffer.getMemoryRequirements();
    auto memProperties = physicalDevice.getMemoryProperties();
    
    uint32_t memoryTypeIndex = UINT32_MAX;
    for (uint32_t i = 0; i < memProperties.memoryTypeCount; ++i) {
        if ((memRequirements.memoryTypeBits & (1 << i)) &&
            (memProperties.memoryTypes[i].propertyFlags & vk::MemoryPropertyFlagBits::eHostVisible)) {
            memoryTypeIndex = i;
            break;
        }
    }
    ASSERT_NE(memoryTypeIndex, UINT32_MAX);
    
    vk::MemoryAllocateInfo allocInfo{
        memRequirements.size,
        memoryTypeIndex
    };
    
    vk::raii::DeviceMemory memory(device, allocInfo);
    indirectBuffer.bindMemory(*memory, 0);
    
    // Write indirect dispatch parameters
    DispatchIndirectCommand* mappedMemory = static_cast<DispatchIndirectCommand*>(
        memory.mapMemory(0, bufferSize)
    );
    mappedMemory->x = 32;
    mappedMemory->y = 16;
    mappedMemory->z = 1;
    memory.unmapMemory();
    
    // Create pipeline layout
    vk::PipelineLayoutCreateInfo layoutInfo{};
    vk::raii::PipelineLayout pipelineLayout(device, layoutInfo);
    
    // Allocate command buffer
    vk::CommandBufferAllocateInfo cmdAllocInfo{
        *commandPool,
        vk::CommandBufferLevel::ePrimary,
        1
    };
    auto commandBuffers = vk::raii::CommandBuffers(device, cmdAllocInfo);
    
    // Record indirect dispatch
    commandBuffers[0].begin({vk::CommandBufferUsageFlagBits::eOneTimeSubmit});
    
    // Would bind pipeline here in real scenario
    commandBuffers[0].dispatchIndirect(*indirectBuffer, 0);
    
    commandBuffers[0].end();
    
    EXPECT_TRUE(*commandBuffers[0]) << "Command buffer with indirect dispatch should be valid";
}

// Test 9: Shader Local Memory (Shared Memory)
TEST_F(SPIRVShaderTest, SharedMemoryUsage) {
    auto properties = physicalDevice.getProperties();
    auto sharedMemorySize = properties.limits.maxComputeSharedMemorySize;
    
    EXPECT_GE(sharedMemorySize, 16384) << "Shared memory should be at least 16KB";
    
    // Test workgroup size limits for shared memory usage
    auto maxWorkGroupSize = properties.limits.maxComputeWorkGroupInvocations;
    auto maxWorkGroupSizeX = properties.limits.maxComputeWorkGroupSize[0];
    
    // Calculate optimal workgroup size for shared memory
    uint32_t elementsPerThread = 4;
    uint32_t bytesPerElement = sizeof(float);
    uint32_t maxThreadsForSharedMem = sharedMemorySize / (elementsPerThread * bytesPerElement);
    
    uint32_t optimalWorkgroupSize = std::min(
        static_cast<uint32_t>(maxThreadsForSharedMem),
        static_cast<uint32_t>(maxWorkGroupSize)
    );
    
    EXPECT_GT(optimalWorkgroupSize, 0) << "Should be able to use shared memory";
}

// Test 10: Pipeline Cache
TEST_F(SPIRVShaderTest, PipelineCache) {
    // Create pipeline cache
    vk::PipelineCacheCreateInfo cacheInfo{};
    vk::raii::PipelineCache pipelineCache(device, cacheInfo);
    
    ASSERT_TRUE(*pipelineCache) << "Pipeline cache creation failed";
    
    // Get cache data (initially empty)
    auto cacheData = pipelineCache.getData();
    size_t initialSize = cacheData.size();
    
    // Create pipeline layout
    vk::PipelineLayoutCreateInfo layoutInfo{};
    vk::raii::PipelineLayout pipelineLayout(device, layoutInfo);
    
    // Create shader module
    auto spirvCode = createAddShaderSPIRV();
    vk::ShaderModuleCreateInfo shaderInfo{
        {},
        spirvCode.size() * sizeof(uint32_t),
        spirvCode.data()
    };
    
    try {
        vk::raii::ShaderModule shaderModule(device, shaderInfo);
        
        // Create compute pipeline with cache
        vk::ComputePipelineCreateInfo pipelineInfo{
            {},
            {
                {},
                vk::ShaderStageFlagBits::eCompute,
                *shaderModule,
                "main"
            },
            *pipelineLayout
        };
        
        auto pipelines = vk::raii::Pipelines(device, *pipelineCache, pipelineInfo);
        
        // Get cache data after pipeline creation
        auto newCacheData = pipelineCache.getData();
        
        // Cache should potentially have grown (implementation dependent)
        EXPECT_GE(newCacheData.size(), initialSize);
    } catch (const vk::SystemError& e) {
        GTEST_SKIP() << "Skipping with placeholder SPIR-V";
    }
}

} // namespace mlsdk::tests